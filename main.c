#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
#include "images/start_screen.h"
#include "images/start_screen.c"
#include "images/birdSprite.h"
#include "images/birdSprite.c"
#include "images/bottom_pipe.c"
#include "images/bottom_pipe.h"
#include "images/top_pipe.h"
#include "images/top_pipe.c"
#include "images/win_screen.h"
#include "images/win_screen.c"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state
{
  START,
  PLAY,
  WIN,
  LOSE,
};

int main(void)
{
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;
  // Load initial application state
  enum gba_state state = START;
  struct bird flappyBird;
  flappyBird.x = 10;
  flappyBird.height = 40;
  static int score = 0;
  static int pipeX = (SCREEN_WIDTH - PIPE_WIDTH);
  static int pipeTop = 70;
  static int speed = 1;
  static int personalBest = 0;
  static int drawEnd = 0;
  static int drawZero = 0;
  static int drawLose = 0;
  while (1)
  {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw
    waitForVBlank();
    switch (state)
    {
    case START:
      if ((vBlankCounter / 60 % 2) == 0)
      {
        drawFullScreenImageDMA(start_screen);
      }
      else
      {
        if (vBlankCounter % 60 == 0)
        {
          drawCenteredString(120 + randint(-20, 20), 80 + randint(-20, 20), 80, 10, "Press enter to start", RED);
        }
      }
      if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons))
      {
        fillScreenDMA(BLACK);
        state = PLAY;
      }
      break;
    case PLAY:
      drawRectDMA(flappyBird.height, flappyBird.x, 32, 23, BLACK);
      drawRectDMA(pipeTop, pipeX + PIPE_WIDTH, speed, 16, BLACK);
      drawString(20, 160, "Score: ", GREEN);
      if (!drawZero)
      {
        drawString(20, 200, "0", GREEN);
        drawZero = 1;
      }
      // check logic on newest change
      if (vBlankCounter % 2 == 0 && flappyBird.height <= (SCREEN_HEIGHT - 23))
      {
        flappyBird.height++;
      }
      if (KEY_DOWN(BUTTON_UP, currentButtons) && flappyBird.height >= 0)
      {
        flappyBird.height -= 2;
      }
      if (KEY_DOWN(BUTTON_RIGHT, currentButtons) && flappyBird.x <= 25)
      {
        flappyBird.x += 1;
      }
      if (KEY_DOWN(BUTTON_LEFT, currentButtons) && flappyBird.x >= 0)
      {
        flappyBird.x -= 1;
      }
      if (KEY_DOWN(BUTTON_SELECT, currentButtons))
      {
        state = START;
        break;
      }
      if (flappyBird.height < 0 || flappyBird.height > (SCREEN_HEIGHT - 23))
      {
        state = LOSE;
        break;
      }
      if (flappyBird.height + BIRD_HEIGHT > pipeTop && flappyBird.x + BIRD_WIDTH > pipeX && flappyBird.x < pipeX + PIPE_WIDTH)
      {
        state = LOSE;
        break;
      }
      drawImageDMA(flappyBird.height, flappyBird.x, 32, 23, birdSprite);
      drawImageDMA(pipeTop, pipeX, PIPE_WIDTH, SCREEN_HEIGHT - pipeTop, bottom_pipe);
      if (pipeX < 0)
      {
        drawRectDMA(0, (SCREEN_WIDTH - PIPE_WIDTH), PIPE_WIDTH, SCREEN_HEIGHT, BLACK);
        if (pipeX <= -PIPE_WIDTH)
        {
          pipeTop = randint(50, 140);
          pipeX = (SCREEN_WIDTH - PIPE_WIDTH);
          score++;
          if (score > personalBest)
          {
            personalBest = score;
          }
          char buffer[20];
          drawRectDMA(15, 180, 60, 20, BLACK);
          snprintf(buffer, 20, "%d", score);
          drawString(20, 200, buffer, GREEN);
          if (score == 10)
          {
            speed = 2;
          }
          if (score == 50)
          {
            state = WIN;
            break;
          }
        }
      }
      pipeX -= speed;
      break;
    case WIN:
      if (!drawEnd)
      {
        drawFullScreenImageDMA(WinScreen);
        char buffer[63];
        snprintf(buffer, 63, "High Score: %d Return to start", personalBest);
        drawCenteredString(10, 100, 40, 20, buffer, GREEN);
        drawEnd = 1;
      }
      if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
      {
        drawZero = 0;
        state = START;
        flappyBird.height = 40;
        flappyBird.x = 10;
        score = 0;
        pipeX = (SCREEN_WIDTH - PIPE_WIDTH);
        pipeTop = 70;
        drawEnd = 0;
      }
      break;
    case LOSE:
      if (!drawLose)
      {
        char buffer[63];
        drawCenteredString(120, 80, 80, 10, "YOU LOSE, PRESS ENTER TO RESTART", RED);
        snprintf(buffer, 63, "High Score: %d ", personalBest);
        drawCenteredString(135, 100, 40, 20, buffer, GREEN);
        drawLose = 1;
      }
      if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons))
      {
        fillScreenDMA(BLACK);
        drawLose = 0;
        drawZero = 0;
        state = PLAY;
        flappyBird.height = 40;
        flappyBird.x = 10;
        score = 0;
        pipeX = (SCREEN_WIDTH - PIPE_WIDTH);
        pipeTop = 70;
        speed = 1;
      }
      else if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons))
      {
        drawZero = 0;
        state = START;
        flappyBird.height = 40;
        flappyBird.x = 10;
        score = 0;
        pipeX = (SCREEN_WIDTH - PIPE_WIDTH);
        pipeTop = 70;
        speed = 1;
      }
      break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
